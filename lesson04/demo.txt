Итого у нас лёгкость модификации, повторного использования в других проектах (без переписывания), тестирования, написания и чтения. Какими методами мы добились?

===================================

- Разделили код на универсальный и изменчивый
- Инкапсулировали изменчивость
- Разделили код по логическим обязанностям. Корзина ведёт элементы, их сохраняет и подсчитывает.
- Разбили по обязанностям на корзину, хранилище и калькулятор.
- Определили интерфейсы для изменчивых реализаций и переключились на них.

===================================

SOLID

===================================

Single responsibility principle SRP
    Принцип единственной обязанности
    класс должен иметь только одну причину для изменения.

Open/closed principle
    Принцип открытости/закрытости
    «программные сущности должны быть открыты для расширения, но закрыты для модификации.»

Liskov substitution principle
    Принцип подстановки Барбары Лисков
    «объекты должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.»

Interface segregation principle
    Принцип разделения интерфейса
    «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»

Dependency inversion principle
    Принцип инверсии зависимостей
    «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»